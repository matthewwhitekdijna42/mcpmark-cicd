name: Issue Management Automation
on:
  issues:
    types: [opened, labeled]

jobs:
  issue-triage:
    runs-on: ubuntu-latest
    steps:
      - name: Create required labels if missing
        uses: actions/github-script@v7
        with:
          script: |
            const requiredLabels = [
              // Category Labels
              { name: 'bug', color: 'd73a4a', description: 'Something isn\'t working' },
              { name: 'enhancement', color: 'a2eeef', description: 'New feature or request' },
              { name: 'epic', color: '0052cc', description: 'Large feature requiring multiple sub-tasks' },
              { name: 'maintenance', color: 'fef2c0', description: 'Maintenance and housekeeping tasks' },
              // Priority Labels
              { name: 'priority-critical', color: 'b60205', description: 'Critical priority issue' },
              { name: 'priority-high', color: 'ff9f1c', description: 'High priority issue' },
              { name: 'priority-medium', color: 'ffcc00', description: 'Medium priority issue' },
              { name: 'priority-low', color: '0e8a16', description: 'Low priority issue' },
              // Status Labels
              { name: 'needs-triage', color: 'fbca04', description: 'Needs to be reviewed by maintainers' },
              { name: 'needs-review', color: '008672', description: 'Awaiting review from maintainers' },
              { name: 'first-time-contributor', color: '1d76db', description: 'Issue created by first-time contributor' }
            ];

            for (const label of requiredLabels) {
              try {
                await github.rest.labels.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  name: label.name,
                  color: label.color,
                  description: label.description
                });
              } catch (error) {
                // Ignore if label already exists (status 422)
                if (error.status !== 422) {
                  console.error(`Failed to create label ${label.name}:`, error);
                  throw error;
                }
              }
            }

      - name: Triage issue
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.issue;
            const title = issue.title.toLowerCase();
            const body = issue.body ? issue.body.toLowerCase() : '';
            const currentLabels = issue.labels.map(label => label.name);

            // Add needs-triage label if not present
            if (!currentLabels.includes('needs-triage')) {
              await github.rest.issues.addLabels({
                issue_number: issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                labels: ['needs-triage']
              });
            }

            // Assign category label based on title
            let categoryAssigned = false;
            if (title.includes('bug')) {
              await github.rest.issues.addLabels({
                issue_number: issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                labels: ['bug']
              });
              categoryAssigned = true;
            } else if (title.includes('epic')) {
              await github.rest.issues.addLabels({
                issue_number: issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                labels: ['epic']
              });
              categoryAssigned = true;
            } else if (title.includes('maintenance')) {
              await github.rest.issues.addLabels({
                issue_number: issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                labels: ['maintenance']
              });
              categoryAssigned = true;
            }

            // Assign priority label (highest priority first)
            const priorityMap = [
              { label: 'priority-critical', keywords: ['critical', 'urgent', 'production', 'outage'] },
              { label: 'priority-high', keywords: ['important', 'high', 'blocking'] },
              { label: 'priority-medium', keywords: ['medium', 'normal'] },
              { label: 'priority-low', keywords: ['low', 'nice-to-have', 'minor'] }
            ];

            let priorityAssigned = false;
            for (const priority of priorityMap) {
              const hasKeyword = priority.keywords.some(keyword => 
                title.includes(keyword) || body.includes(keyword)
              );
              if (hasKeyword) {
                await github.rest.issues.addLabels({
                  issue_number: issue.number,
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  labels: [priority.label]
                });
                priorityAssigned = true;
                break;
              }
            }

            // Default to medium priority if no keywords found
            if (!priorityAssigned) {
              await github.rest.issues.addLabels({
                issue_number: issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                labels: ['priority-medium']
              });
            }

  task-breakdown:
    runs-on: ubuntu-latest
    needs: issue-triage
    if: github.event.action == 'opened' && contains(github.event.issue.labels.*.name, 'epic')
    steps:
      - name: Create epic subtasks
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.issue;
            const parentTitle = issue.title;
            const parentNumber = issue.number;
            const repo = context.repo;

            // Define subtasks
            const subtasks = [
              { name: "Requirements Analysis" },
              { name: "Design and Architecture" },
              { name: "Implementation" },
              { name: "Testing and Documentation" }
            ];

            // Create subtasks and collect their numbers
            const subtaskNumbers = [];
            for (let i = 0; i < subtasks.length; i++) {
              const subtask = subtasks[i];
              const subtaskTitle = `[SUBTASK] ${parentTitle} - Task ${i + 1}: ${subtask.name}`;
              
              const createdSubtask = await github.rest.issues.create({
                owner: repo.owner,
                repo: repo.repo,
                title: subtaskTitle,
                body: `Related to #${parentNumber}`,
                labels: ['enhancement', 'needs-review']
              });

              subtaskNumbers.push(createdSubtask.data.number);
            }

            // Update parent issue with subtask checklist
            const checklist = subtaskNumbers.map(num => `- [ ] #${num}`).join('\n');
            const updatedBody = `${issue.body || ''}\n\n## Epic Tasks\n${checklist}`;

            await github.rest.issues.update({
              issue_number: parentNumber,
              owner: repo.owner,
              repo: repo.repo,
              body: updatedBody
            });

  auto-response:
    runs-on: ubuntu-latest
    needs: [issue-triage, task-breakdown]
    if: github.event.action == 'opened'
    steps:
      - name: Generate auto-response and update issue
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.issue;
            const author = issue.user.login;
            const repo = context.repo;
            const currentLabels = issue.labels.map(label => label.name);

            // Check if this is the author's first issue in the repo
            const userIssues = await github.rest.issues.listForRepo({
              owner: repo.owner,
              repo: repo.repo,
              creator: author,
              per_page: 2
            });
            const isFirstIssue = userIssues.data.length === 1;

            // Add first-time-contributor label if applicable
            if (isFirstIssue) {
              await github.rest.issues.addLabels({
                issue_number: issue.number,
                owner: repo.owner,
                repo: repo.repo,
                labels: ['first-time-contributor']
              });
            }

            // Build response comment
            let comment = '';
            
            // Welcome message for first-time contributors
            if (isFirstIssue) {
              comment += "Welcome! This is your first issue in this repository. We appreciate your contribution!\n\n";
            }

            // Add guidelines based on issue category
            if (currentLabels.includes('bug')) {
              comment += "### Bug Report Guidelines\nPlease ensure you've provided:\n- Steps to reproduce the issue\n- Expected behavior\n- Actual behavior\n- Screenshots (if applicable)\n- Environment details (Node.js version, OS, etc.)";
            } else if (currentLabels.includes('epic')) {
              comment += "### Feature Request Process\nThis epic will be broken down into subtasks. Please provide:\n- Detailed requirements\n- User stories (if applicable)\n- Acceptance criteria";
            } else if (currentLabels.includes('maintenance')) {
              comment += "### Maintenance Guidelines\nFor maintenance tasks, please include:\n- Scope of the cleanup/refactor\n- Any specific files or modules to target\n- Expected outcomes or improvements";
            }

            // Post the comment
            await github.rest.issues.createComment({
              issue_number: issue.number,
              owner: repo.owner,
              repo: repo.repo,
              body: comment
            });

            // Set milestone for high/critical priority issues
            if (currentLabels.includes('priority-high') || currentLabels.includes('priority-critical')) {
              try {
                // Try to set milestone v1.0.0 (create if it doesn't exist)
                let milestone;
                try {
                  // Check if milestone exists
                  milestone = await github.rest.milestones.get({
                    owner: repo.owner,
                    repo: repo.repo,
                    milestone_number: 1
                  });
                } catch (error) {
                  // If milestone doesn't exist, create it
                  if (error.status === 404) {
                    milestone = await github.rest.milestones.create({
                      owner: repo.owner,
                      repo: repo.repo,
                      title: "v1.0.0"
                    });
                  } else {
                    throw error;
                  }
                }

                await github.rest.issues.update({
                  issue_number: issue.number,
                  owner: repo.owner,
                  repo: repo.repo,
                  milestone: milestone.data.number
                });
              } catch (error) {
                console.error("Failed to set milestone:", error);
              }
            }

            // Update status from needs-triage to needs-review
            await github.rest.issues.removeLabel({
              issue_number: issue.number,
              owner: repo.owner,
              repo: repo.repo,
              name: 'needs-triage'
            });

            await github.rest.issues.addLabels({
              issue_number: issue.number,
              owner: repo.owner,
              repo: repo.repo,
              labels: ['needs-review']
            });